/******************************************************************************
* File Name:   main.c
*
* Description: This is the source code for the XMC MCU: SCU Sleep mode
*              for ModusToolbox.
*
* Related Document: See README.md
*
******************************************************************************
*
* Copyright (c) 2015-2021, Infineon Technologies AG
* All rights reserved.                        
*                                             
* Boost Software License - Version 1.0 - August 17th, 2003
* 
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
* 
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*                                                                              
*****************************************************************************/

#include "cybsp.h"
#include "cy_utils.h"
#include "xmc_eru.h"

/*******************************************************************************
* Macros
*******************************************************************************/

#ifdef  TARGET_KIT_XMC14_BOOT_001
#define EXTERNAL_INPUT_SIGNAL_PIN     ERU0_ETL1_INPUTA_P2_5
#define ERU_GROUP_ETL_CHANNEL         ERU0_ETL1
#define ERU_GROUP_OGU_CHANNEL         ERU0_OGU0
#define INTERRUPT_PRIORITY_NODE_ID    IRQ3_IRQn
#define INTERRUPT_EVENT_PRIORITY      (3U)
#define ERU_EXTERNAL_EVENT_HANDLER    IRQ_Hdlr_3
#endif

#ifdef  TARGET_KIT_XMC47_RELAX_V1
#define EXTERNAL_INPUT_SIGNAL_PIN     ERU1_ETL1_INPUTA_P1_15
#define ERU_GROUP_ETL_CHANNEL         ERU1_ETL1
#define ERU_GROUP_OGU_CHANNEL         ERU1_OGU0
#define INTERRUPT_PRIORITY_NODE_ID    ERU1_0_IRQn
#define INTERRUPT_EVENT_PRIORITY      (63U)
#define ERU_EXTERNAL_EVENT_HANDLER    IRQ_Hdlr_5
#endif

#define ENABLE_DEEP_SLEEP_MODE        (0U)
#define CYCLE_DELAY_COUNT             (20000000U)

/*******************************************************************************
* Data Structure
*******************************************************************************/
/*Structure for initializing ERUx_ETLy module*/
static const XMC_ERU_ETL_CONFIG_t button_event_generator_config =
{
    .input                  = EXTERNAL_INPUT_SIGNAL_PIN,             /*Configures input signal for Event request source unit */
    .source                 = XMC_ERU_ETL_SOURCE_A,                  /*Input path combination along with polarity for event generation.*/
    .edge_detection         = XMC_ERU_ETL_EDGE_DETECTION_FALLING,    /*Configure the event trigger edge(FE, RE)*/
    .status_flag_mode       = XMC_ERU_ETL_STATUS_FLAG_MODE_HWCTRL,   /*Status flag is in non-sticky mode. Automatically cleared by the opposite edge detection*/
    .enable_output_trigger  = true,                                  /*Enables the generation of trigger pulse(PE)*/
    .output_trigger_channel = XMC_ERU_ETL_OUTPUT_TRIGGER_CHANNEL0    /*Output channel select(OCS) for ETLx output trigger pulse.*/
};

/*Structure for initializing ERUx_OGUy module.*/
static const XMC_ERU_OGU_CONFIG_t button_event_detection_config =
{
    .service_request        = XMC_ERU_OGU_SERVICE_REQUEST_ON_TRIGGER  /*Gating(GP) on service request generation for pattern detection result*/
};

/*******************************************************************************
* Function Name: delay
********************************************************************************
* Summary:
* This is the delay generation function based on the MCU clock cycles
*
* Parameters:
*  uint32_t cycles
*
* Return:
*  void
*
*******************************************************************************/
 void delay(uint32_t cycles)
{
    while(--cycles)
    {
        __NOP();       /* No operation */
    }
}

/*******************************************************************************
* Function Name: ERU_EXTERNAL_EVENT_HANDLER
********************************************************************************
* Summary:
* This is the interrupt handler function for the ERU external interrupt.
* This is use to wake up controller from sleep mode
* Inside Interrupt service routine LED will glow and then goes off after a small delay
*
* Parameters:
*  none
*
* Return:
*  void
*
*******************************************************************************/
void ERU_EXTERNAL_EVENT_HANDLER(void)
{
    /*Toggle the LED*/
    XMC_GPIO_ToggleOutput(CYBSP_USER_LED_PORT, CYBSP_USER_LED_PIN);
    /*DO something, waste cycles here for generating delay*/
    delay(CYCLE_DELAY_COUNT);
    /*Toggle the LED*/
    XMC_GPIO_ToggleOutput(CYBSP_USER_LED_PORT, CYBSP_USER_LED_PIN);
}

/*******************************************************************************
* Function Name: main
********************************************************************************
* Summary:
* This is the main function.
* This example demonstrate how to program XMC into sleep mode
* Wake up is done by using External Interrupt via ERU
* On Board LED glows with some delay inside external event handler and then go off
* Processor is put back to sleep mode after servicing interrupt service routine
* Wait for Interrupt (WFI) command causes immediate entry into sleep mode
*
* Parameters:
*  none
*
* Return:
*  int
*
*******************************************************************************/
int main(void)
{
    cy_rslt_t result;

    /* Initialize the device and board peripherals */
    result = cybsp_init();
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /*Initializes the selected ERU_ETLx channel with the configuration structure*/
    XMC_ERU_ETL_Init(ERU_GROUP_ETL_CHANNEL, &button_event_generator_config);

    /*Initializes the selected ERU_OGUy channel with the configuration structure*/
    XMC_ERU_OGU_Init(ERU_GROUP_OGU_CHANNEL, &button_event_detection_config);

#ifdef TARGET_KIT_XMC14_BOOT_001
    /*Set Priority for IRQ*/
    NVIC_SetPriority(INTERRUPT_PRIORITY_NODE_ID,INTERRUPT_EVENT_PRIORITY);
#endif

#ifdef TARGET_KIT_XMC47_RELAX_V1
    /*Set Priority for IRQ*/
    NVIC_SetPriority(INTERRUPT_PRIORITY_NODE_ID,NVIC_EncodePriority(NVIC_GetPriorityGrouping(),INTERRUPT_EVENT_PRIORITY, 0));
#endif

    /*Enable the Interrupt*/
    NVIC_EnableIRQ(INTERRUPT_PRIORITY_NODE_ID);

    /*Enable the sleep or deep sleep mode*/
#if ENABLE_DEEP_SLEEP_MODE == 1
    SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
#else
    SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
#endif

    /*Enable sleep-on-exit feature, Immediately enter sleep mode after execution of exception handlers*/
    SCB->SCR |= SCB_SCR_SLEEPONEXIT_Msk;

    /* Infinite loop */
    while(1)
    {
        /*Data Synchronization Barrier,it completes when all explicit memory accesses before this instruction complete*/
        __DSB();

        /* Wait For Interrupt is a hint instruction that suspends execution and enters sleep mode until one of a number of events occurs*/
        __WFI();
    }
}

/* [] END OF FILE */